import { NextRequest, NextResponse } from 'next/server'
import { prisma } from '@/lib/prisma'

export async function POST(request: NextRequest) {
  try {
    const { analysisId, format = 'json' } = await request.json()

    if (!analysisId) {
      return NextResponse.json({ error: 'Analysis ID required' }, { status: 400 })
    }

    const analysis = await prisma.analysisJob.findUnique({
      where: { id: analysisId },
      include: { rubric: { select: { title: true, researchGoals: true } } },
    })

    if (!analysis) {
      return NextResponse.json({ error: 'Analysis not found' }, { status: 404 })
    }

    const themes = (analysis.themes as any[]) || []
    const insights = (analysis.insights as any[]) || []
    const recommendations = (analysis.recommendations as any[]) || []

    const slides: any[] = [
      { type: 'title', title: analysis.rubric.title, subtitle: 'Research Analysis Report', footer: `${analysis.interviewCount} Interviews | ${analysis.completedAt?.toLocaleDateString()}` },
      { type: 'content', title: 'Executive Summary', bullets: [`${analysis.interviewCount} interviews analyzed`, `${themes.length} themes identified`, `${insights.length} insights discovered`, `${recommendations.length} recommendations`, `${analysis.confidence || 0}% confidence`] },
      { type: 'content', title: 'Research Goals', content: analysis.rubric.researchGoals },
      { type: 'content', title: 'Key Themes', bullets: themes.slice(0, 6).map(t => `${t.name} (${t.prevalence}%)`) },
    ]

    themes.slice(0, 5).forEach((theme, idx) => {
      slides.push({
        type: 'content',
        title: `Theme ${idx + 1}: ${theme.name}`,
        subtitle: `${theme.prevalence}% prevalence`,
        content: theme.description,
        quote: theme.supportingQuotes?.[0]?.quote,
      })
    })

    slides.push({ type: 'content', title: 'Key Insights', bullets: insights.slice(0, 5).map(i => i.text) })

    recommendations.forEach((rec, idx) => {
      slides.push({
        type: 'content',
        title: `Recommendation ${idx + 1}`,
        subtitle: `Priority: ${rec.priority.toUpperCase()}`,
        content: rec.text,
        bullets: [rec.impact ? `Impact: ${rec.impact}` : null].filter(Boolean),
      })
    })

    slides.push({ type: 'closing', title: 'Thank You', content: 'Questions?', footer: 'Generated by Resonance' })

    if (format === 'markdown-slides') {
      let markdown = ''
      slides.forEach((slide) => {
        markdown += `---\n\n# ${slide.title}\n\n`
        if (slide.subtitle) markdown += `*${slide.subtitle}*\n\n`
        if (slide.content) markdown += `${slide.content}\n\n`
        if (slide.bullets?.length) slide.bullets.forEach((b: string) => { markdown += `- ${b}\n` })
        if (slide.quote) markdown += `\n> "${slide.quote}"\n`
        markdown += '\n'
      })

      const filename = `slides-${analysis.rubric.title.replace(/[^a-z0-9]/gi, '-').substring(0, 30)}.md`
      return new NextResponse(markdown, {
        headers: { 'Content-Type': 'text/markdown', 'Content-Disposition': `attachment; filename="${filename}"` },
      })
    }

    const filename = `slides-${analysis.rubric.title.replace(/[^a-z0-9]/gi, '-').substring(0, 30)}.json`
    return new NextResponse(JSON.stringify({ slides }, null, 2), {
      headers: { 'Content-Type': 'application/json', 'Content-Disposition': `attachment; filename="${filename}"` },
    })
  } catch (error) {
    console.error('Export error:', error)
    return NextResponse.json({ error: 'Failed to export' }, { status: 500 })
  }
}
